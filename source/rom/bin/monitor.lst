ca65 V2.19 - Git 12193790e
Main file   : monitor.s
Current file: monitor.s

000000r 1               ;*********************************************************
000000r 1               ;* APPLE /// ROM - MONITOR
000000r 1               ;* COPYRIGHT 1979 BY APPLE COMPUTER, INC.
000000r 1               ;*********************************************************
000000r 1               
000000r 1                          .setcpu "6502"
000000r 1                          .segment "CODE"
000000r 1               
000000r 1               ;           .PROC   MONITOR
000000r 1                          .ORG    $F7FE
00F7FE  1               ;
00F7FE  1               ;
00F7FE  1  60           RET1:      RTS
00F7FF  1  3F                      .BYTE   $3F
00F800  1  E9 01                   SBC     #01
00F802  1  F0 FA                   BEQ     RET1
00F804  1  E9 01                   SBC     #01
00F806  1  F0 F6                   BEQ     RET1
00F808  1  E9 01                   SBC     #01
00F80A  1  F0 F2                   BEQ     RET1
00F80C  1  E9 01                   SBC     #01
00F80E  1  F0 EE                   BEQ     RET1
00F810  1  E9 01                   SBC     #01
00F812  1  F0 EA                   BEQ     RET1
00F814  1  E9 01                   SBC     #01
00F816  1  F0 E6                   BEQ     RET1
00F818  1  E9 01                   SBC     #01
00F81A  1  F0 E2                   BEQ     RET1
00F81C  1  E9 01                   SBC     #01
00F81E  1  F0 DE                   BEQ     RET1
00F820  1  E9 01                   SBC     #01
00F822  1  F0 DA                   BEQ     RET1
00F824  1  E9 01                   SBC     #01
00F826  1  F0 D6                   BEQ     RET1
00F828  1  E9 01                   SBC     #01
00F82A  1  F0 D2                   BEQ     RET1
00F82C  1  E9 01                   SBC     #01
00F82E  1  F0 CE                   BEQ     RET1
00F830  1  E9 01                   SBC     #01
00F832  1  F0 CA                   BEQ     RET1
00F834  1  E9 01                   SBC     #01
00F836  1  F0 C6                   BEQ     RET1
00F838  1  E9 01                   SBC     #01
00F83A  1  F0 C2                   BEQ     RET1
00F83C  1  E9 01                   SBC     #01
00F83E  1  F0 BE                   BEQ     RET1
00F840  1  E9 01                   SBC     #01
00F842  1  F0 BA                   BEQ     RET1
00F844  1  E9 01                   SBC     #01
00F846  1  F0 B6                   BEQ     RET1
00F848  1  E9 01                   SBC     #01
00F84A  1  F0 B2                   BEQ     RET1
00F84C  1  E9 01                   SBC     #01
00F84E  1  F0 AE                   BEQ     RET1
00F850  1  E9 01                   SBC     #01
00F852  1  F0 AA                   BEQ     RET1
00F854  1  E9 01                   SBC     #01
00F856  1  F0 A6                   BEQ     RET1
00F858  1  E9 01                   SBC     #01
00F85A  1  F0 A2                   BEQ     RET1
00F85C  1  E9 01                   SBC     #01
00F85E  1  F0 9E                   BEQ     RET1
00F860  1  E9 01                   SBC     #01
00F862  1  F0 9A                   BEQ     RET1
00F864  1  E9 01                   SBC     #01
00F866  1  F0 96                   BEQ     RET1
00F868  1  E9 01                   SBC     #01
00F86A  1  F0 92                   BEQ     RET1
00F86C  1  E9 01                   SBC     #01
00F86E  1  F0 8E                   BEQ     RET1
00F870  1  E9 01                   SBC     #01
00F872  1  F0 8A                   BEQ     RET1
00F874  1  E9 01                   SBC     #01
00F876  1  F0 86                   BEQ     RET1
00F878  1  E9 01                   SBC     #01
00F87A  1  F0 82                   BEQ     RET1
00F87C  1  E9 01                   SBC     #01
00F87E  1  F0 02                   BEQ     RET3
00F880  1  E9 01                   SBC     #01
00F882  1  F0 7C         RET3:     BEQ     RET2
00F884  1  E9 01                   SBC     #01
00F886  1  F0 78                   BEQ     RET2
00F888  1  E9 01                   SBC     #01
00F88A  1  F0 74                   BEQ     RET2
00F88C  1  E9 01                   SBC     #01
00F88E  1  F0 70                   BEQ     RET2
00F890  1  E9 01                   SBC     #01
00F892  1  F0 6C                   BEQ     RET2
00F894  1  E9 01                   SBC     #01
00F896  1  F0 68                   BEQ     RET2
00F898  1  E9 01                   SBC     #01
00F89A  1  F0 64                   BEQ     RET2
00F89C  1  E9 01                   SBC     #01
00F89E  1  F0 60                   BEQ     RET2
00F8A0  1  E9 01                   SBC     #01
00F8A2  1  F0 5C                   BEQ     RET2
00F8A4  1  E9 01                   SBC     #01
00F8A6  1  F0 58                   BEQ     RET2
00F8A8  1  E9 01                   SBC     #01
00F8AA  1  F0 54                   BEQ     RET2
00F8AC  1  E9 01                   SBC     #01
00F8AE  1  F0 50                   BEQ     RET2
00F8B0  1  E9 01                   SBC     #01
00F8B2  1  F0 4C                   BEQ     RET2
00F8B4  1  E9 01                   SBC     #01
00F8B6  1  F0 48                   BEQ     RET2
00F8B8  1  E9 01                   SBC     #01
00F8BA  1  F0 44                   BEQ     RET2
00F8BC  1  E9 01                   SBC     #01
00F8BE  1  F0 40                   BEQ     RET2
00F8C0  1  E9 01                   SBC     #01
00F8C2  1  F0 3C                   BEQ     RET2
00F8C4  1  E9 01                   SBC     #01
00F8C6  1  F0 38                   BEQ     RET2
00F8C8  1  E9 01                   SBC     #01
00F8CA  1  F0 34                   BEQ     RET2
00F8CC  1  E9 01                   SBC     #01
00F8CE  1  F0 30                   BEQ     RET2
00F8D0  1  E9 01                   SBC     #01
00F8D2  1  F0 2C                   BEQ     RET2
00F8D4  1  E9 01                   SBC     #01
00F8D6  1  F0 28                   BEQ     RET2
00F8D8  1  E9 01                   SBC     #01
00F8DA  1  F0 24                   BEQ     RET2
00F8DC  1  E9 01                   SBC     #01
00F8DE  1  F0 20                   BEQ     RET2
00F8E0  1  E9 01                   SBC     #01
00F8E2  1  F0 1C                   BEQ     RET2
00F8E4  1  E9 01                   SBC     #01
00F8E6  1  F0 18                   BEQ     RET2
00F8E8  1  E9 01                   SBC     #01
00F8EA  1  F0 14                   BEQ     RET2
00F8EC  1  E9 01                   SBC     #01
00F8EE  1  F0 10                   BEQ     RET2
00F8F0  1  E9 01                   SBC     #01
00F8F2  1  F0 0C                   BEQ     RET2
00F8F4  1  E9 01                   SBC     #01
00F8F6  1  F0 08                   BEQ     RET2
00F8F8  1  E9 01                   SBC     #01
00F8FA  1  F0 04                   BEQ     RET2
00F8FC  1  E9 01                   SBC     #01
00F8FE  1  F0 00                   BEQ     RET2
00F900  1  60           RET2:      RTS
00F901  1               
00F901  1               
00F901  1               SCRNLOC    =    $58
00F901  1               
00F901  1               LMARGIN    =    SCRNLOC
00F901  1               RMARGIN    =    SCRNLOC+1
00F901  1               WINTOP     =    SCRNLOC+2
00F901  1               WINBTM     =    SCRNLOC+3
00F901  1               CH         =    SCRNLOC+4
00F901  1               CV         =    SCRNLOC+5
00F901  1               BAS4L      =    SCRNLOC+6
00F901  1               BAS4H      =    SCRNLOC+7
00F901  1               BAS8L      =    SCRNLOC+8
00F901  1               BAS8H      =    SCRNLOC+9
00F901  1               TBAS4L     =    SCRNLOC+$0A
00F901  1               TBAS4H     =    SCRNLOC+$0B
00F901  1               TBAS8L     =    SCRNLOC+$0C
00F901  1               TBAS8H     =    SCRNLOC+$0D
00F901  1               FORGND     =    SCRNLOC+$0E
00F901  1               BKGND      =    SCRNLOC+$0F
00F901  1               MODES      =    SCRNLOC+$10
00F901  1               CURSOR     =    SCRNLOC+$11
00F901  1               STACK      =    SCRNLOC+$12
00F901  1               PROMPT     =    SCRNLOC+$13
00F901  1               TEMPX      =    SCRNLOC+$14
00F901  1               TEMPY      =    SCRNLOC+$15
00F901  1               CSWL       =    SCRNLOC+$16
00F901  1               CSWH       =    SCRNLOC+$17
00F901  1               KSWL       =    SCRNLOC+$18
00F901  1               KSWH       =    SCRNLOC+$19
00F901  1               PCL        =    SCRNLOC+$1A
00F901  1               PCH        =    SCRNLOC+$1B
00F901  1               A1L        =    SCRNLOC+$1C
00F901  1               A1H        =    A1L+1
00F901  1               A2L        =    A1L+2
00F901  1               A2H        =    A1L+3
00F901  1               A3L        =    A1L+4
00F901  1               A3H        =    A1L+5
00F901  1               A4L        =    A1L+6
00F901  1               A4H        =    A1L+7
00F901  1               STATE      =    A1L+8
00F901  1               YSAV       =    A1L+9
00F901  1               INBUF      =    A1L+$0A
00F901  1               TEMP       =    A1L+$0C
00F901  1               MASK       =    CURSOR
00F901  1               
00F901  1               KBD        =    $C000
00F901  1               KBDSTRB    =    $C010
00F901  1               
00F901  1               USERADR    =    $3F8
00F901  1               BLOCKIO    =    $F479
00F901  1               RECON      =    $F686      ;      AS OF 12/20/1979
00F901  1               DIAGN      =    $F4EE
00F901  1               INBUFLEN   =    $50        ;      ONLY 80 BYTES      ($3A0-$3EF)
00F901  1               IBSLOT     =    $81
00F901  1               IBDRVN     =    IBSLOT+1
00F901  1               IBBUFP     =    IBSLOT+4
00F901  1               IBCMD      =    IBSLOT+6
00F901  1               
00F901  1               ENTRY      =    *
00F901  1  BA                      TSX
00F902  1  86 6A                   STX     STACK
00F904  1  D8           MON:       CLD                  ; MUST BE HEX MODE
00F905  1  20 4E FC                JSR     BELL
00F908  1  A6 6A        MONZ:      LDX     STACK        ; RESTORE STACK TO ORIGINAL LOCATION
00F90A  1  9A                      TXS
00F90B  1  A9 DF                   LDA     #$DF         ; PROMPT (APPLE) FOR SARA MONITOR
00F90D  1  85 6B                   STA     PROMPT
00F90F  1  20 D5 FC                JSR     GETLNZ       ; GET A LINE OF INPUT
00F912  1  20 67 F9     SCAN:      JSR     ZSTATE       ; SET REGULAR SCAN
00F915  1  20 2C F9     NXTINP:    JSR     GETNUM       ; ATTEMPT TO READ HEX BYTE
00F918  1  84 7D                   STY     YSAV         ; STORE CURRENT INPUT POINTER
00F91A  1  A0 12                   LDY     #$12         ; 18 COMMANDS
00F91C  1  88           CMDSRCH:   DEY
00F91D  1  30 E5                   BMI     MON          ; GIVE UP IF UNRECOGNIZABLE
00F91F  1  D9 6C F9                CMP     CMDTAB,Y     ; FOUND?
00F922  1  D0 F8                   BNE     CMDSRCH      ; NO KEEP LOOKING
00F924  1  20 5E F9                JSR     TOSUB        ; PERFORM FUNCTION
00F927  1  A4 7D                   LDY     YSAV         ; GET NEXT POINTER
00F929  1  4C 15 F9                JMP     NXTINP       ; DO NEXT COMMAND
00F92C  1               
00F92C  1  A2 00        GETNUM:    LDX     #00          ; CLEAR A2
00F92E  1  86 76                   STX     A2L
00F930  1  86 77                   STX     A2H
00F932  1  B1 7E        NXTCHR:    LDA     (INBUF),Y
00F934  1  C8                      INY                  ; BUMP INDEX FOR NEXT TIME
00F935  1  49 B0                   EOR     #$B0
00F937  1  C9 0A                   CMP     #$0A         ; TEST FOR DIGIT
00F939  1  90 06                   BCC     DIGIT        ; SAVE IT IF 1-9
00F93B  1  69 88                   ADC     #$88         ; TEST FOR HEX A-F
00F93D  1  C9 FA                   CMP     #$FA
00F93F  1  90 2A                   BCC     DIGRET
00F941  1  A2 03        DIGIT:     LDX     #03
00F943  1  0A                      ASL     A
00F944  1  0A                      ASL     A
00F945  1  0A                      ASL     A
00F946  1  0A                      ASL     A
00F947  1  0A           NXTBIT:    ASL     A            ; SHIFT HEX DIGITS INTO A2
00F948  1  26 76                   ROL     A2L
00F94A  1  26 77                   ROL     A2H
00F94C  1  CA                      DEX
00F94D  1  10 F8                   BPL     NXTBIT       ; SHIFTED ALL YET?
00F94F  1  A5 7C        NXTBAS:    LDA     STATE
00F951  1  D0 06                   BNE     NXTBS2       ; IF ZERO THEN COPY TO A1,3
00F953  1  B5 77                   LDA     A2H,X
00F955  1  95 75                   STA     A1H,X
00F957  1  95 79                   STA     A3H,X
00F959  1  E8           NXTBS2:    INX
00F95A  1  F0 F3                   BEQ     NXTBAS
00F95C  1  D0 D4                   BNE     NXTCHR
00F95E  1               ;
00F95E  1               ; SWITCH ROUTINE FOR CHARACTER
00F95E  1               ;
00F95E  1  A9 FA        TOSUB:     LDA     #$FA         ; PUSH ADDRESS OR FUNCTION
00F960  1  48                      PHA                  ; AND RETURN IT
00F961  1  B9 7D F9                LDA     CMDVEC,Y
00F964  1  48                      PHA
00F965  1  A5 7C                   LDA     STATE        ; PASS MODE VIA ACC.
00F967  1  A0 00        ZSTATE:    LDY     #00
00F969  1  84 7C                   STY     STATE        ; RESET STATE OF SCAN
00F96B  1  60           DIGRET:    RTS
00F96C  1               CMDTAB     =    *
00F96C  1  00                      .BYTE   $00          ; G    =GP (CALL) SUBROUTINE
00F96D  1  03                      .BYTE   $03          ; J    =JUMP (CONT) PROGRAM
00F96E  1  06                      .BYTE   $06          ; M    =MOVE MEMORY
00F96F  1  EB                      .BYTE   $EB          ; R    =READ DISK BLOCK
00F970  1  EC                      .BYTE   $EC          ; S    =MEMORY SEARCH
00F971  1  EE                      .BYTE   $EE          ; U    =USER FUNCTION
00F972  1  EF                      .BYTE   $EF          ; V    =VERIFY MEMORY BLOCKS
00F973  1  F0                      .BYTE   $F0          ; W    =WRITE DISK BLOCK
00F974  1  F1                      .BYTE   $F1          ; X    =REPEAT COMMAND LINE
00F975  1  99                      .BYTE   $99          ; SP   =SPACE (BYTE SEPARATOR)
00F976  1  9B                      .BYTE   $9B          ; *    =ASCII (HI BIT ON)
00F977  1  A0                      .BYTE   $A0          ; '    =ASCII (HI BIT OFF)
00F978  1  93                      .BYTE   $93          ; :    =SET STORE MODE
00F979  1  A7                      .BYTE   $A7          ; .    =RANGE SEPARATOR
00F97A  1  A8                      .BYTE   $A8          ; /    =COMMAND SEPARATOR
00F97B  1  95                      .BYTE   $95          ; <    =DEST/SOURCE SEPARATOR
00F97C  1  C6                      .BYTE   $C6          ; CR   =CARRIAGE RETURN
00F97D  1               
00F97D  1               CMDVEC     =    *
00F97D  1  90                      .BYTE   $90          ; GO-1
00F97E  1  8E                      .BYTE   $8E          ; JUMP-1
00F97F  1  3F                      .BYTE   $3F          ; MOVE-1
00F980  1  D3                      .BYTE   $D3          ; READ-1
00F981  1  08                      .BYTE   $08          ; SEARCH-1
00F982  1  8B                      .BYTE   $8B          ; USER-1
00F983  1  4E                      .BYTE   $4E          ; VRFY-1
00F984  1  D6                      .BYTE   $D6          ; WRTE-1
00F985  1  2C                      .BYTE   $2C          ; REPEAT-1
00F986  1  B7                      .BYTE   $B7          ; SPCE-1
00F987  1  1A                      .BYTE   $1A          ; ASCII-1
00F988  1  1C                      .BYTE   $1C          ; ASCII0-1
00F989  1  CB                      .BYTE   $CB          ; SETMODE-1
00F98A  1  CB                      .BYTE   $CB          ; SETMODE-1
00F98B  1  AD                      .BYTE   $AD          ; SEP-1
00F98C  1  A4                      .BYTE   $A4          ; DEST-1
00F98D  1  39                      .BYTE   $39          ; CRMON-1
00F98E  1               ;
00F98E  1               ;
00F98E  1  E6 7A        NXTA4:     INC     A4L          ; BUMP 16 BIT POINTERS
00F990  1  D0 02                   BNE     NXTA1
00F992  1  E6 7B                   INC     A4H
00F994  1  E6 74        NXTA1:     INC     A1L          ; BUMP AL
00F996  1  D0 05                   BNE     TSTA1
00F998  1  E6 75                   INC     A1H
00F99A  1  38                      SEC                  ; IN CASE OF ROLL OVER
00F99B  1  F0 10                   BEQ     RETA1
00F99D  1  A5 74        TSTA1:     LDA     A1L
00F99F  1  38                      SEC
00F9A0  1  E5 76                   SBC     A2L
00F9A2  1  85 80                   STA     TEMP
00F9A4  1  A5 75                   LDA     A1H
00F9A6  1  E5 77                   SBC     A2H
00F9A8  1  05 80                   ORA     TEMP
00F9AA  1  D0 01                   BNE     RETA1        ; IF AL LESS THAN OR EQUAL TO A2
00F9AC  1  18                      CLC                  ; THEN CARRY CLEAR ON RETURN
00F9AD  1  60           RETA1:     RTS
00F9AE  1               ;
00F9AE  1               ;
00F9AE  1  48           PRBYTE:    PHA                  ; SAVE LOW NIBBLE
00F9AF  1  4A                      LSR     A
00F9B0  1  4A                      LSR     A            ; SHIFT HI NIBBLE TO PRINT.
00F9B1  1  4A                      LSR     A
00F9B2  1  4A                      LSR     A
00F9B3  1  20 B9 F9                JSR     PRHEXZ
00F9B6  1  68                      PLA
00F9B7  1  29 0F        PRHEX:     AND     #$0F         ; STRIP HI NIBBLE
00F9B9  1  09 B0        PRHEXZ:    ORA     #$B0         ; MAKE IT NUMERIC
00F9BB  1  C9 BA                   CMP     #$BA         ; IS IT >'9'
00F9BD  1  90 02                   BCC     PRHEX2
00F9BF  1  69 06                   ADC     #06          ; MAKE IT 'A'-'F'
00F9C1  1  4C 39 FC     PRHEX2:    JMP     COUT
00F9C4  1               ;
00F9C4  1  20 AE F9     PRBYCOL:   JSR     PRBYTE
00F9C7  1               ;
00F9C7  1  A9 BA        PRCOLON:   LDA     #$BA         ; PRINT A COLON
00F9C9  1  D0 F6                   BNE     PRHEX2       ; BRANCH ALWAYS
00F9CB  1               ;
00F9CB  1  A9 07        TST80WID:  LDA     #07          ; ANTICIPATE
00F9CD  1  24 68                   BIT     MODES        ; TEST FOR 80
00F9CF  1  50 02                   BVC     SVMASK
00F9D1  1  A9 0F                   LDA     #$0F
00F9D3  1  85 69        SVMASK:    STA     MASK
00F9D5  1  60                      RTS
00F9D6  1               ;
00F9D6  1  8A           A1PC:      TXA                  ; TEST FOR NEW PC
00F9D7  1  F0 07                   BEQ     OLDPC
00F9D9  1  B5 74        A1PC1:     LDA     A1L,X
00F9DB  1  95 72                   STA     PCL,X
00F9DD  1  CA                      DEX
00F9DE  1  10 F9                   BPL     A1PC1
00F9E0  1  60           OLDPC:     RTS
00F9E1  1               ;
00F9E1  1  85 69        ASCII1:    STA     MASK         ; SAVE HI BIT STATUS
00F9E3  1  A4 7D        ASCII2:    LDY     YSAV         ; MOVE ASCII TO MEMORY
00F9E5  1  B1 7E                   LDA     (INBUF),Y
00F9E7  1  E6 7D                   INC     YSAV         ; BUMP FOR NEXT THING.
00F9E9  1  A0 00                   LDY     #00
00F9EB  1  C9 A2                   CMP     #$A2         ; ASCII " ?
00F9ED  1  D0 05                   BNE     ASCII3       ; NOPE, CONTINUE.
00F9EF  1  A5 69                   LDA     MASK
00F9F1  1  10 32                   BPL     BITON        ; HE'S CHANGED MODES.
00F9F3  1  60                      RTS
00F9F4  1  C9 A7        ASCII3:    CMP     #$A7         ; ASCII ' ?
00F9F6  1  D0 05                   BNE     CRCHK        ; NO, TEST FOR EOL.
00F9F8  1  A5 69                   LDA     MASK
00F9FA  1  30 2D                   BMI     BITOFF       ; CHANGE MODES.
00F9FC  1  60                      RTS
00F9FD  1               ;
00F9FD  1  C9 8D        CRCHK:     CMP     #$8D         ; END OF LINE?
00F9FF  1  F0 07                   BEQ     ASCDONE      ; YES, FINISHED
00FA01  1  25 69                   AND     MASK
00FA03  1  20 C3 FA                JSR     STOR1        ; GO STORE IT!
00FA06  1  D0 DB                   BNE     ASCII2       ; DO NEXT.
00FA08  1  60           ASCDONE:   RTS
00FA09  1               ;
00FA09  1               ;
00FA09  1  B1 74        SEARCH:    LDA     (A1L),Y      ; LOAD SEARCH BYTE
00FA0B  1  C5 7A                   CMP     A4L
00FA0D  1  D0 06                   BNE     SRCH1
00FA0F  1  20 75 FA                JSR     PRINTA1      ; DUMP MEMORY
00FA12  1  20 EF FC                JSR     CROUT
00FA15  1  20 94 F9     SRCH1:     JSR     NXTA1        ; INCREMENT POINTER
00FA18  1  90 EF                   BCC     SEARCH       ; CONTINUE SEARCH
00FA1A  1  60                      RTS                  ; RETURN
00FA1B  1               ;
00FA1B  1               ;
00FA1B  1  38           ASCII:     SEC                  ; INDICATE HI ON.
00FA1C  1  90                      .BYTE   $90          ; (BCC - NEVER TAKEN)
00FA1D  1  18           ASCII0:    CLC                  ; INDICATE HI OFF
00FA1E  1  AA           CKMDE:     TAX                  ; SAVE STATE
00FA1F  1  86 7C                   STX     STATE        ; RETAIN STATE
00FA21  1  49 BA                   EOR     #$BA         ; ARE WE IN STORE MODE?
00FA23  1  D0 7D                   BNE     ERROR
00FA25  1  A9 FF        BITON:     LDA     #$FF         ; SET HI BIT UNMASKED
00FA27  1  B0 B8                   BCS     ASCII1
00FA29  1  A9 7F        BITOFF:    LDA     #$7F         ; MASK HI BIT
00FA2B  1  10 B4                   BPL     ASCII1       ; ALWAYS BRANCHES
00FA2D  1  2C 00 C0     REPEAT:    BIT     KBD          ; REPEAT UNTIL KEYPRESS
00FA30  1  10 03                   BPL     REPEAT1
00FA32  1  4C 0F FD                JMP     KEYIN
00FA35  1  68           REPEAT1:   PLA                  ; CLEAN UP STACK
00FA36  1  68           LFA36:     PLA
00FA37  1  4C 12 F9                JMP     SCAN
00FA3A  1               ;
00FA3A  1               ;
00FA3A  1  20 B4 FA     CRMON:     JSR     BL1
00FA3D  1  4C 08 F9                JMP     MONZ
00FA40  1               ;
00FA40  1               ;
00FA40  1  20 9D F9     MOVE:      JSR     TSTA1        ; TEST VALID RANGE
00FA43  1  B0 5D                   BCS     ERROR
00FA45  1  B1 74        MOVNXT:    LDA     (A1L),Y      ; COMPARE BYTE FOR BYTE
00FA47  1  91 7A                   STA     (A4L),Y
00FA49  1  20 8E F9                JSR     NXTA4        ; BUMP BOTH AL AND A4
00FA4C  1  90 F7                   BCC     MOVNXT
00FA4E  1  60                      RTS                  ; ALL DONE WITH MOVE
00FA4F  1               ;
00FA4F  1  20 9D F9     VRFY:      JSR     TSTA1        ; TEST VALID RANGE
00FA52  1  B0 4E                   BCS     ERROR
00FA54  1  B1 74        VRFY1:     LDA     (A1L),Y      ; COMPARE BYTE FOR BYTE
00FA56  1  D1 7A                   CMP     (A4L),Y      ; MATCH?
00FA58  1  F0 06                   BEQ     VRFY2        ; YES, DO NEXT.
00FA5A  1  20 66 FA                JSR     MISMATCH     ; PRINT BOTH BYTES
00FA5D  1  20 EF FC                JSR     CROUT        ; GOTO NEWLINE
00FA60  1  20 8E F9     VRFY2:     JSR     NXTA4        ; BUMP BOTH AL AND A4
00FA63  1  90 EF                   BCC     VRFY1
00FA65  1  60                      RTS                  ; VERIFY DONE.
00FA66  1               ;
00FA66  1  A5 7B        MISMATCH:  LDA     A4H          ; PRINT ADDRESS OF A4
00FA68  1  20 AE F9                JSR     PRBYTE
00FA6B  1  A5 7A                   LDA     A4L
00FA6D  1  20 C4 F9                JSR     PRBYCOL      ; OUTPUT A COLON FOR SEPARATOR
00FA70  1  B1 7A                   LDA     (A4L),Y      ; AND THE DATA
00FA72  1  20 84 FA                JSR     PRBYTSP      ; PRINT THE BYTE AND A SPACE
00FA75  1  20 87 FA     PRINTA1:   JSR     PRSPC        ; LEAD WITH A SPACE
00FA78  1  A5 75                   LDA     A1H          ; OUTPUT ADDRESS AL
00FA7A  1  20 AE F9                JSR     PRBYTE
00FA7D  1  A5 74                   LDA     A1L
00FA7F  1  20 C4 F9                JSR     PRBYCOL      ; SEPARATE WITH A COLON
00FA82  1  B1 74        PRA1BYTE:  LDA     (A1L),Y      ; PRINT BYTE POINTED TO BY AL
00FA84  1  20 AE F9     PRBYTSP:   JSR     PRBYTE
00FA87  1  A9 A0        PRSPC:     LDA     #$A0         ; PRINT A SPACE
00FA89  1  4C 39 FC                JMP     COUT         ; END VIA OUTPUT ROUTINE.
00FA8C  1               ;
00FA8C  1  4C F8 03     USER:      JMP     USERADR
00FA8F  1               ;
00FA8F  1  68           JUMP:      PLA
00FA90  1  68                      PLA                  ; LEAVE STACK WITH NOTHIN' ON IT.
00FA91  1  20 D6 F9     GO:        JSR     A1PC         ; STUFF PROGRAM COUNTER
00FA94  1  6C 72 00                JMP     (PCL)        ; JUMP TO USER PROD.
00FA97  1               ;
00FA97  1               RWERROR    =       *            ; PRINT ERROR NUMBER
00FA97  1  20 AE F9                JSR     PRBYTE       ; PRINT THE OFFENDER
00FA9A  1  A9 A1                   LDA     #$A1         ; FOLLOWED BY A "!"
00FA9C  1  20 39 FC                JSR     COUT
00FA9F  1  20 07 FD     ERROR2:    JSR     NOSTOP       ; OUTPUT A CARRIAGE RETURN (NO STOPLST)
00FAA2  1  4C 04 F9     ERROR:     JMP     MON
00FAA5  1               ;
00FAA5  1  A5 76        DEST:      LDA     A2L          ; COPY A2 TO A4 FOR DESTINATION OP
00FAA7  1  85 7A                   STA     A4L
00FAA9  1  A5 77                   LDA     A2H
00FAAB  1  85 7B                   STA     A4H
00FAAD  1  60                      RTS
00FAAE  1               ;
00FAAE  1  20 B8 FA     SEP:       JSR     SPCE         ; SEPARATOR TEST STORE MODE OR DUMP.
00FAB1  1  98                      TYA                  ; ZERO MODE.
00FAB2  1  F0 1D                   BEQ     SETMDZ       ; BRANCH ALWAYS
00FAB4  1               ;
00FAB4  1  C6 7D        BL1:       DEC     YSAV         ; TEST FOR NO LINE
00FAB6  1  F0 45                   BEQ     DUMP8        ; IF NO LINE, GIVEM A ROW OF BYTES
00FAB8  1  CA           SPCE:      DEX                  ; TEST IF AFTER ANOTHER SPACE
00FAB9  1  D0 16                   BNE     SETMDZ
00FABB  1  C9 BA                   CMP     #$BA         ; STORE MODE?
00FABD  1  D0 4B                   BNE     TSTDUMP
00FABF  1  85 7C        STOR:      STA     STATE        ; KEEP IT IN STORE STATE
00FAC1  1  A5 76                   LDA     A2L          ; GET BYTE TO BE STORED
00FAC3  1  91 78        STOR1:     STA     (A3L),Y      ; PUT IT IN MEMORY.
00FAC5  1  E6 78                   INC     A3L          ; BUMP POINTER
00FAC7  1  D0 02                   BNE     DUMMY
00FAC9  1  E6 79                   INC     A3H
00FACB  1  60           DUMMY:     RTS                  ; ALSO USED FOR '/' TO CLEAR MODE
00FACC  1               ;
00FACC  1  A4 7D        SETMODE:   LDY     YSAV         ; USE INPUT CHARACTER
00FACE  1  88                      DEY
00FACF  1  B1 7E                   LDA     (INBUF),Y    ; TO SET MODE
00FAD1  1  85 7C        SETMDZ:    STA     STATE
00FAD3  1  60                      RTS
00FAD4  1               ;
00FAD4  1  A9 01        READ:      LDA     #01          ; GET DISK COMMAND TO READ
00FAD6  1  2C                      .BYTE   $2C          ; DUMMY BIT TO SKIP 2 BYTES
00FAD7  1  A9 02        WRTE:      LDA     #02          ; SET DISK COMMAND TO WRITE
00FAD9  1  85 87        SAVCMD:    STA     IBCMD
00FADB  1  A5 74        RWLOOP:    LDA     A1L
00FADD  1  85 85                   STA     IBBUFP       ; COMMAND FORMAT IS
00FADF  1  A5 75                   LDA     A1H          ; BLOCKNUMBER <ADDRESS END ADDRESS
00FAE1  1  85 86                   STA     IBBUFP+1
00FAE3  1  A6 7B                   LDX     A4H          ; SEND BLOCK NUMBER VIA X & A
00FAE5  1  A5 7A                   LDA     A4L
00FAE7  1  78                      SEI                  ; NO INTERRUPTS WHILE IN MONITOR
00FAE8  1  20 79 F4                JSR     BLOCKIO      ; DO DISKO FEVER
00FAEB  1  B0 AA                   BCS     RWERROR      ; GIVE UP IF ERROR ENCOUNTERED
00FAED  1  E6 7A                   INC     A4L          ; BUMP BLOCK NUMBER
00FAEF  1  D0 02                   BNE     NOVER
00FAF1  1  E6 7B                   INC     A4H
00FAF3  1  E6 75        NOVER:     INC     A1H          ; BUMP RAM ADDRESS BY 512 BYTES
00FAF5  1  E6 75                   INC     A1H
00FAF7  1  20 9D F9                JSR     TSTA1        ; TEST FOR FINISHED
00FAFA  1  90 DF                   BCC     RWLOOP       ; NOT DONE, DO NEXT BLOCK
00FAFC  1  60                      RTS
00FAFD  1               ;
00FAFD  1  A5 75        DUMP8:     LDA     A1H
00FAFF  1  85 77                   STA     A2H
00FB01  1  20 CB F9                JSR     TST80WID     ; GET WIDTH MASK INTO ACC
00FB04  1  05 74                   ORA     A1L
00FB06  1  85 76                   STA     A2L
00FB08  1  D0 06                   BNE     DUMP0        ; BRANCH ALWAYS
00FB0A  1               ;
00FB0A  1  4A           TSTDUMP:   LSR     A            ; DUMP?
00FB0B  1  B0 95        ERROR1:    BCS     ERROR
00FB0D  1  20 CB F9     DUMP:      JSR     TST80WID     ; SET FOR EITHER 80 OR 40 COLUMNS
00FB10  1  A5 74        DUMP0:     LDA     A1L
00FB12  1  85 7A                   STA     A4L
00FB14  1  A5 75                   LDA     A1H
00FB16  1  85 7B                   STA     A4H
00FB18  1  20 9D F9                JSR     TSTA1        ; TEST FOR VALID RANGE
00FB1B  1  B0 EE                   BCS     ERROR1
00FB1D  1  20 75 FA     DUMP1:     JSR     PRINTA1      ; PRINT ADDRESS AND FIRST BYTE
00FB20  1  20 94 F9     DUMP2:     JSR     NXTA1
00FB23  1  B0 10                   BCS     DUMPASC      ; END WITH ASCII
00FB25  1  A5 74                   LDA     A1L          ; TEST END OF LINE
00FB27  1  25 69                   AND     MASK         ; FOR 40/80 COLUMN
00FB29  1  D0 05                   BNE     DUMP3
00FB2B  1  20 35 FB                JSR     DUMPASC
00FB2E  1  D0 ED                   BNE     DUMP1        ; BRANCH ALWAYS
00FB30  1  20 82 FA     DUMP3:     JSR     PRA1BYTE     ; GO PRINT NEXT BYTE AND A SPACE
00FB33  1  D0 EB                   BNE     DUMP2        ; ALWAYS (ACC JUST PULLED AS $A0)
00FB35  1               ;
00FB35  1  A5 7A        DUMPASC:   LDA     A4L          ; RESET TO BEGINNING OF LINE
00FB37  1  85 74                   STA     A1L
00FB39  1  A5 7B                   LDA     A4H
00FB3B  1  85 75                   STA     A1H
00FB3D  1  20 87 FA                JSR     PRSPC        ; PRINT AN EXTRA SPACE
00FB40  1  A0 00        ASC1:      LDY     #00          ; TO INDEX MEMORY INDIRECT
00FB42  1  B1 74                   LDA     (A1L),Y
00FB44  1  09 80                   ORA     #$80         ; SET NORMAL VIDEO
00FB46  1  C9 A0                   CMP     #$A0         ; TEST FOR CONTROL CHARACTERS
00FB48  1  B0 02                   BCS     ASC2         ; OK TO PRINT NON CONTROLS
00FB4A  1  A9 AE                   LDA     #$AE         ; OTHERWISE PRINT A SPACE
00FB4C  1  20 39 FC     ASC2:      JSR     COUT         ; PUT IT OUT
00FB4F  1  20 8E F9                JSR     NXTA4        ; BUMP BOTH AL AND A4
00FB52  1  B0 06                   BCS     ASC3         ; FINISHED
00FB54  1  A5 74                   LDA     A1L          ; TEST END OF LINE
00FB56  1  25 69                   AND     MASK
00FB58  1  D0 E6                   BNE     ASC1         ; NOT DONE, PRINT NEXT
00FB5A  1  4C EF FC     ASC3:      JMP     CROUT
00FB5D  1               ;
00FB5D  1               ;
00FB5D  1  38           COL80:     SEC                  ; INDICATE 80 COLUMNS
00FB5E  1  AD 53 C0                LDA     $C053        ; GOTO 80 COLUMN MODE
00FB61  1  B0 04                   BCS     SET80        ; BRANCH ALWAYS
00FB63  1               ;
00FB63  1  18           COL40:     CLC                  ; INDICATE 40 COLUMNS DESIRED
00FB64  1  AD 52 C0                LDA     $C052        ; GOTO 40 COLUMN MODE
00FB67  1  A5 68        SET80:     LDA     MODES
00FB69  1  09 40                   ORA     #$40         ; ASSUME 80
00FB6B  1  B0 02                   BCS     SET80A       ; AND BRANCH IF IT IS
00FB6D  1  29 BF                   AND     #$BF         ; BUT FIX FOR 40 IF NOT
00FB6F  1  85 68        SET80A:    STA     MODES
00FB71  1  09 7F                   ORA     #$7F         ; ISOLATE BIT 7
00FB73  1  29 A0                   AND     #$A0         ; (BIT 7 SETS NORMAL/INVERSE)
00FB75  1  85 66                   STA     FORGND
00FB77  1  B0 02                   BCS     SET80B       ; AGAIN ASSUMES 80 COLUMNS
00FB79  1  A9 F0                   LDA     #$F0         ; IF NOT, SET FOR/BACKGROUND COLOR
00FB7B  1  85 67        SET80B:    STA     BKGND
00FB7D  1               ;
00FB7D  1  A5 58        CLSCRN:    LDA     LMARGIN      ; SET CURSOR TO TOP LEFT OF WINDOW
00FB7F  1  85 5C                   STA     CH
00FB81  1  A5 5A                   LDA     WINTOP
00FB83  1  85 5D                   STA     CV           ; NOW DROP INTO CLEAR END OF PAGE
00FB85  1               ;
00FB85  1  A5 5C        CLEOP:     LDA     CH           ; SAVE CURRENT CURSOR POSITION
00FB87  1  48                      PHA
00FB88  1  A5 5D                   LDA     CV
00FB8A  1  48                      PHA
00FB8B  1  20 C5 FB                JSR     SETCV
00FB8E  1  20 A2 FB     CLEOP1:    JSR     CLEOL        ; CLEAR TO END OF FIRST LINE
00FB91  1  A5 58                   LDA     LMARGIN
00FB93  1  85 5C                   STA     CH
00FB95  1  20 DD FB                JSR     CURDOWN      ; GOTO NEXT LINE
00FB98  1  90 F4                   BCC     CLEOP1
00FB9A  1  68                      PLA
00FB9B  1  A8                      TAY
00FB9C  1  68                      PLA                  ; RESTORE CURSOR POSITION
00FB9D  1  85 5C                   STA     CH
00FB9F  1  98                      TYA                  ; GET OLD CV IN ACC AGAIN
00FBA0  1  B0 23                   BCS     SETCV        ; BRANCH ALWAYS
00FBA2  1               ;
00FBA2  1  A5 5C        CLEOL:     LDA     CH           ; CLEAR TO END OF LINE FIRST
00FBA4  1  4C 89 FC                JMP     CLEOL1
00FBA7  1               ;
00FBA7  1  C9 80        CONTROL:   CMP     #$80
00FBA9  1  90 65                   BCC     DISPLAYX     ; IF INVERSE
00FBAB  1  C9 8D        TSTCR:     CMP     #$8D         ; IF CARRIAGE RETURN THEN NEW LINE
00FBAD  1  D0 3A                   BNE     TSTBACK
00FBAF  1  20 A2 FB     CARRAGE:   JSR     CLEOL        ; FIRST CLEAR TO THE END OF THIS LINE
00FBB2  1  20 D7 FB                JSR     SETCHZ       ; RESET CURSOR AND GOTO NEXT LINE (CARRY IS SET)
00FBB5  1  4C 16 FC                JMP     NXTLIN       ; THEN GOTO THE NEXT LINE.
00FBB8  1               ;
00FBB8  1               ;
00FBB8  1  A5 5D        CURUP:     LDA     CV           ; TEST FOR TOP OF SCREEN
00FBBA  1  C6 5D                   DEC     CV           ; ANTICIPATE 'NOT' TOP
00FBBC  1  C5 5A                   CMP     WINTOP
00FBBE  1  D0 02                   BNE     CURUP1       ; IT'S NOT TOP, CONTINUE
00FBC0  1  A5 5B                   LDA     WINBTM       ; WRAP AROUND TO BOTTOM
00FBC2  1  38           CURUP1:    SEC                  ; DECREMENT BY ONE
00FBC3  1  E9 01                   SBC     #01
00FBC5  1  85 5D        SETCV:     STA     CV           ; SAVE NEW VERTICAL LINE
00FBC7  1               BASCALC    =       *
00FBC7  1               CURDN1     =       *
00FBC7  1  A5 5D                   LDA     CV           ; GET VALUES FOR FIRST PAGE ($400)
00FBC9  1  10 4E                   BPL     BASCALC1     ; ALWAYS
00FBCB  1               ;
00FBCB  1  24 68        CURIGHT:   BIT     MODES        ; TEST FOR 80 OR 40
00FBCD  1  70 02                   BVS     RIGHT1
00FBCF  1  E6 5C                   INC     CH
00FBD1  1  E6 5C        RIGHT1:    INC     CH           ; BUMP CURSOR HORIZONTAL
00FBD3  1  A5 5C                   LDA     CH           ; TEST FOR NEW LINE
00FBD5  1  C5 59                   CMP     RMARGIN
00FBD7  1  A5 58        SETCHZ:    LDA     LMARGIN      ; JUST IN CASE WE HAVE.
00FBD9  1  90 5D                   BCC     CTRLRET
00FBDB  1  85 5C        SETCVH:    STA     CH           ; CURSOR AT START OF NEXT LINE
00FBDD  1               ; DROP INTO CURDOWN FOR WRAP AROUND
00FBDD  1               ;
00FBDD  1  E6 5D        CURDOWN:   INC     CV           ; MOVE CURSOR DOWN ONE LINE
00FBDF  1  A5 5D                   LDA     CV           ; ANTICIPATE NOT BOTTOM
00FBE1  1  C5 5B                   CMP     WINBTM       ; TEST FOR BOTTOM
00FBE3  1  90 E2                   BCC     CURDN1
00FBE5  1  A5 5A                   LDA     WINTOP
00FBE7  1  B0 DC                   BCS     SETCV        ; BRANCH ALWAYS
00FBE9  1               ;
00FBE9  1  C9 88        TSTBACK:   CMP     #$88          ; BACKSPACE?
00FBEB  1  D0 5D                   BNE     TSTBELL
00FBED  1  24 68        CURLEFT:   BIT     MODES        ; TEST FOR FOURTY OR EIGHTY MODE
00FBEF  1  70 02                   BVS     LEFT80
00FBF1  1  C6 5C                   DEC     CH
00FBF3  1  C6 5C        LEFT80:    DEC     CH
00FBF5  1  30 06                   BMI     LEFTUP
00FBF7  1  A5 5C                   LDA     CH           ; TEST FOR WRAP AROUND
00FBF9  1  C5 58                   CMP     LMARGIN
00FBFB  1  10 3B                   BPL     CTRLRET
00FBFD  1  20 B8 FB     LEFTUP:    JSR     CURUP
00FC00  1  A5 59                   LDA     RMARGIN
00FC02  1  85 5C                   STA     CH           ; SAVE NEW CURSOR POSITION
00FC04  1  D0 E7                   BNE     CURLEFT      ; BRANCH ALWAYS
00FC06  1               ;
00FC06  1  C9 A0        COUT2:     CMP     #$A0         ; IS IT CONTROL CHARACTER
00FC08  1  90 9D                   BCC     CONTROL
00FC0A  1  24 68                   BIT     MODES        ; TEST FOR INVERSE
00FC0C  1  30 02                   BMI     DISPLAYX     ; NO PUT IT OUT
00FC0E  1  29 7F                   AND     #$7F          ; STRIP HI BIT
00FC10  1  20 9D FC     DISPLAYX:  JSR     DISPLAY
00FC13  1               ;
00FC13  1  20 CB FB     INCHORZ:   JSR     CURIGHT      ; MOVE CURSOR RIGHT
00FC16  1  B0 43        NXTLIN:    BCS     SCROLL       ; IT'S BOTTOM, RESET CH=0 AND SCROLL
00FC18  1  60                      RTS                  ; RESET CH ONLY
00FC19  1               ;
00FC19  1  08           BASCALC1:  PHP                  ; CALC BASE ADR IN BAS4L,H
00FC1A  1  48                      PHA
00FC1B  1  4A                      LSR     A            ; FOR GIVEN LINE NO.
00FC1C  1  29 03                   AND     #03          ; 0<=LINE NO.<$17
00FC1E  1  09 04                   ORA     #04          ; ARG=000ABCDE, GENERATE
00FC20  1  85 5F                   STA     BAS4H        ; BAS4H=000001CD
00FC22  1  49 0C                   EOR     #$0C
00FC24  1  85 61                   STA     BAS8H
00FC26  1  68                      PLA                  ; AND
00FC27  1  29 18                   AND     #$18         ; BAS4L=EABAB000
00FC29  1  90 02                   BCC     BSCLC2
00FC2B  1  69 7F                   ADC     #$7F
00FC2D  1  85 5E        BSCLC2:    STA     BAS4L
00FC2F  1  0A                      ASL     A
00FC30  1  0A                      ASL     A
00FC31  1  05 5E                   ORA     BAS4L
00FC33  1  85 5E                   STA     BAS4L
00FC35  1  85 60                   STA     BAS8L        ; SAME FOR PAGE 2
00FC37  1  28                      PLP
00FC38  1  60           CTRLRET:   RTS
00FC39  1               ;
00FC39  1  48           COUT:      PHA                  ; SAVE CHARACTER
00FC3A  1  84 6D                   STY     TEMPY
00FC3C  1  86 6C                   STX     TEMPX
00FC3E  1  20 47 FC                JSR     COUT1
00FC41  1  A4 6D                   LDY     TEMPY
00FC43  1  A6 6C                   LDX     TEMPX
00FC45  1  68                      PLA
00FC46  1  60                      RTS
00FC47  1  6C 6E 00     COUT1:     JMP     (CSWL)        ; NORMALLY COUT1
00FC4A  1               ;
00FC4A  1  C9 87        TSTBELL:   CMP     #$87         ; BELL?
00FC4C  1  D0 04                   BNE     LNFD         ; NO TEST FOR FORM FEED
00FC4E  1  AE 40 C0     BELL:      LDX     $C040        ; SOUND BELL
00FC51  1  60                      RTS
00FC52  1  C9 8A        LNFD:      CMP     #$8A         ; LINE FEED?
00FC54  1  D0 E2                   BNE     CTRLRET
00FC56  1  20 DD FB                JSR     CURDOWN      ; MOVE CURSOR DOWN A LINE
00FC59  1  90 DD                   BCC     CTRLRET      ; BRANCH IF NO SCROLL NECESSARY.
00FC5B  1               ;
00FC5B  1  A5 5A        SCROLL:    LDA     WINTOP       ; START WITH TOP LINE
00FC5D  1  48                      PHA                  ; SAVE IT FOR NOW
00FC5E  1  20 C5 FB                JSR     SETCV        ; GET BASCALC FOR THIS LINE
00FC61  1  A2 03        SCRL1:     LDX     #03          ; MOVE CURRENT BASCALC AS DESTINATION
00FC63  1  B5 5E        SCRL2:     LDA     BAS4L,X
00FC65  1  95 62                   STA     TBAS4L,X     ; (TEMPORARY BASE ADDR.)
00FC67  1  CA                      DEX
00FC68  1  10 F9                   BPL     SCRL2
00FC6A  1  68                      PLA                  ; GET DESTINATION LINE
00FC6B  1  18                      CLC
00FC6C  1  69 01                   ADC     #01          ; CALCULATE SOURCE LINE.
00FC6E  1  C5 5B                   CMP     WINBTM       ; IS IT THE LAST LINE?
00FC70  1  B0 15                   BCS     LASTLN       ; YES, CLEAR IT
00FC72  1  48                      PHA                  ; SAVE AS NEXT DESTINATION LINE
00FC73  1  20 C5 FB                JSR     SETCV        ; GET BASE ADDR FOR SOURCE LINE
00FC76  1  A5 59                   LDA     RMARGIN      ; MOVE SOURCE TO DESTINATION
00FC78  1  4A                      LSR     A            ; DIVIDE BY 2
00FC79  1  A8                      TAY
00FC7A  1  88           SCRL3:     DEY                  ; DONE YET
00FC7B  1  30 E4                   BMI     SCRL1        ; YES, DO NEXT LINE
00FC7D  1  B1 5E                   LDA     (BAS4L),Y
00FC7F  1  91 62                   STA     (TBAS4L),Y
00FC81  1  B1 60                   LDA     (BAS8L),Y
00FC83  1  91 64                   STA     (TBAS8L),Y
00FC85  1  90 F3                   BCC     SCRL3        ; BRANCH ALWAYS
00FC87  1  A5 58        LASTLN:    LDA     LMARGIN      ; BLANK FILL THE LAST LINE
00FC89  1  4A           CLEOL1:    LSR     A            ; DIVIDE BY 2
00FC8A  1  A8                      TAY
00FC8B  1  B0 04                   BCS     CLEOL2
00FC8D  1  A5 66                   LDA     FORGND       ; (NORMALLY A SPACE)
00FC8F  1  91 5E                   STA     (BAS4L),Y
00FC91  1  A5 67        CLEOL2:    LDA     BKGND        ; (IF 80 COLUMNS, ALSO A SPACE)
00FC93  1  91 60                   STA     (BAS8L),Y
00FC95  1  C8                      INY
00FC96  1  98                      TYA                  ; TEST FOR END OF LINE
00FC97  1  0A                      ASL     A            ; MULT BY 2 AGAIN
00FC98  1  C5 59                   CMP     RMARGIN
00FC9A  1  90 ED                   BCC     CLEOL1       ; CONTINUE IF MORE TO DO.
00FC9C  1  60                      RTS                  ; ALL DONE.
00FC9D  1               ;
00FC9D  1  24 68        DISPLAY:   BIT     MODES        ; TEST FOR 40 OR 80
00FC9F  1  70 0C                   BVS     DSPL80       ; STORE THE SINGLE CHARACTERS AND RETURN
00FCA1  1  46 5C                   LSR     CH           ; INSURE PROPER 40 COLUMN DISPLAY
00FCA3  1  06 5C                   ASL     CH           ; BY DROPPING BIT 0
00FCA5  1  20 AD FC                JSR     DSPL80       ; DISPLAY IN $400 PAGE.
00FCA8  1  A5 67                   LDA     BKGND        ; ALSO SET BACKGROUND COLOR
00FCAA  1  91 60        DSPBKGND:  STA     (BAS8L),Y
00FCAC  1  60                      RTS
00FCAD  1               ;
00FCAD  1  48           DSPL80:    PHA                  ; PRESERVE CHARACTER
00FCAE  1  A5 5C                   LDA     CH           ; DETERMINE WHICH PAGE
00FCB0  1  4A                      LSR     A
00FCB1  1  A8                      TAY
00FCB2  1  68                      PLA
00FCB3  1  B0 F5                   BCS     DSPBKGND     ; BRANCH IF $900 PAGE
00FCB5  1  91 5E                   STA     (BAS4L),Y
00FCB7  1  60                      RTS
00FCB8  1               ;
00FCB8  1  B1 7E        NOTCR:     LDA     (INBUF),Y    ; ECHO CHARACTER
00FCBA  1  20 39 FC                JSR     COUT
00FCBD  1  C9 88                   CMP     #$88         ; BACKSPACE
00FCBF  1  F0 1D                   BEQ     BKSPCE
00FCC1  1  C9 98                   CMP     #$98         ; CANCEL?
00FCC3  1  F0 08                   BEQ     CANCEL
00FCC5  1  E6 80                   INC     TEMP
00FCC7  1  A5 80                   LDA     TEMP
00FCC9  1  C9 50                   CMP     #INBUFLEN
00FCCB  1  D0 17                   BNE     NXTCHAR      ; NO WRAP AROUND ALLOWED.
00FCCD  1  A9 DC        CANCEL:    LDA     #$DC         ; OUTPUT BACKSLASH
00FCCF  1  20 39 FC                JSR     COUT
00FCD2  1  20 EF FC                JSR     CROUT
00FCD5  1               GETLNZ     =       *
00FCD5  1  A5 6B        GETLN:     LDA     PROMPT
00FCD7  1  20 39 FC                JSR     COUT
00FCDA  1  A0 01                   LDY     #01
00FCDC  1  84 80                   STY     TEMP         ; START AT BEGINNING OF INBUF
00FCDE  1  A4 80        BKSPCE:    LDY     TEMP
00FCE0  1  F0 F3                   BEQ     GETLN
00FCE2  1  C6 80                   DEC     TEMP         ; BACK UP INPUT BUFFER
00FCE4  1  20 60 FD     NXTCHAR:   JSR     RDCHAR       ; GET INPUT
00FCE7  1  A4 80                   LDY     TEMP
00FCE9  1  91 7E                   STA     (INBUF),Y
00FCEB  1  C9 8D                   CMP     #$8D
00FCED  1  D0 C9                   BNE     NOTCR
00FCEF  1               CROUT      =       *
00FCEF  1  2C 00 C0                BIT     KBD          ; TEST FOR START/STOP
00FCF2  1  10 13                   BPL     NOSTOP
00FCF4  1  20 2E FD                JSR     KEYIN3       ; READ KBD
00FCF7  1  C9 A0                   CMP     #$A0         ; IS IT A SPACE?
00FCF9  1  F0 07                   BEQ     STOPLST      ; YES, PAUSE TIL NEXT KEYPRESS.
00FCFB  1  C9 89                   CMP     #$89         ; QUIT THIS OPERATION
00FCFD  1  D0 08                   BNE     NOSTOP       ; NO,      IGNORE THIS KEY.
00FCFF  1  4C 9F FA                JMP     ERROR2       ; YES, RESTART
00FD02  1  AD 00 C0     STOPLST:   LDA     KBD
00FD05  1  10 FB                   BPL     STOPLST
00FD07  1  A9 8D        NOSTOP:    LDA     #$8D
00FD09  1  4C 39 FC                JMP     COUT
00FD0C  1               ;
00FD0C  1  6C 70 00     RDKEY:     JMP     (KSWL)
00FD0F  1               ;
00FD0F  1  A9 7F        KEYIN:     LDA     #$7F         ; MAKE SURE FIRST IS CURSOR
00FD11  1  85 63                   STA     TBAS4H
00FD13  1  20 88 FD                JSR     PICK         ; GO READ SCREEN
00FD16  1  48           KEYIN1:    PHA                  ; SAVE CHR AT CURSOR POSITION
00FD17  1  20 35 FD                JSR     KEYWAIT      ; TEST FOR KEYPRESS
00FD1A  1  B0 08                   BCS     KEYIN2       ; GO GET IT
00FD1C  1  A5 69                   LDA     CURSOR       ; GIVE THEM AN UNDERSCORE FOR A TIME
00FD1E  1  20 9D FC                JSR     DISPLAY
00FD21  1  20 35 FD                JSR     KEYWAIT      ; GO SEE IF KEYPRESSED
00FD24  1  68           KEYIN2:    PLA
00FD25  1  08                      PHP                  ; SAVE KEYPRESS STATUS
00FD26  1  48                      PHA
00FD27  1  20 9D FC                JSR     DISPLAY
00FD2A  1  68                      PLA
00FD2B  1  28                      PLP
00FD2C  1  90 E8                   BCC     KEYIN1
00FD2E  1  AD 00 C0     KEYIN3:    LDA     KBD          ; READ KEYBOARD
00FD31  1  2C 10 C0     KEYIN4:    BIT     KBDSTRB      ; CLEAR KEYBOARD STROBE
00FD34  1  60                      RTS
00FD35  1  E6 62        KEYWAIT:   INC     TBAS4L       ; JUST KEEP COUNTING
00FD37  1  D0 09                   BNE     KWAIT2
00FD39  1  E6 63                   INC     TBAS4H
00FD3B  1  A9 7F                   LDA     #$7F         ; TEST FOR DONE
00FD3D  1  18                      CLC
00FD3E  1  25 63                   AND     TBAS4H
00FD40  1  F0 05                   BEQ     KEYRET       ; RETURN IF TIMED OUT
00FD42  1  0E 00 C0     KWAIT2:    ASL     KBD
00FD45  1  90 EE                   BCC     KEYWAIT
00FD47  1  60           KEYRET:    RTS
00FD48  1               ;
00FD48  1               ;
00FD48  1               ESC3       =       *
00FD48  1  20 77 FD                JSR     GOESC
00FD4B  1  A5 68        ESCAPE:    LDA     MODES        ; SET TO + SIGN FOR CURSOR MOVES
00FD4D  1  29 80                   AND     #$80
00FD4F  1  49 AB                   EOR     #$AB
00FD51  1  85 69                   STA     CURSOR
00FD53  1  20 0C FD     ESC1:      JSR     RDKEY        ; READ NEXT CHARACTER
00FD56  1  A0 08                   LDY     #$08         ; TEST FOR ESCAPE COMMAND
00FD58  1  D9 F0 FF     ESC2:      CMP     ESCTABL,Y
00FD5B  1  F0 EB                   BEQ     ESC3
00FD5D  1  88                      DEY
00FD5E  1  10 F8                   BPL     ESC2         ; LOOP TIL FOUND OR DONE
00FD60  1               ;
00FD60  1  A9 80        RDCHAR:    LDA     #$80         ; GO READ A CHARACTER
00FD62  1  25 68                   AND     MODES
00FD64  1  85 69                   STA     CURSOR       ; SAVE STANDARD CURSOR
00FD66  1  20 0C FD                JSR     RDKEY
00FD69  1  C9 9B                   CMP     #$9B         ; ESCAPE CHARACTER?
00FD6B  1  F0 DE                   BEQ     ESCAPE
00FD6D  1  C9 95                   CMP     #$95         ; FORWARD COPY?
00FD6F  1  D0 D6                   BNE     KEYRET
00FD71  1  20 88 FD                JSR     PICK         ; GET CHARACTER FROM SCREEN
00FD74  1  09 80                   ORA     #$80         ; SET TO NORMAL ASCII
00FD76  1  60                      RTS
00FD77  1               ;
00FD77  1  A9 FB        GOESC:     LDA     #$FB
00FD79  1  48                      PHA
00FD7A  1  B9 7F FD                LDA     ESCVECT,Y
00FD7D  1  48                      PHA
00FD7E  1  60                      RTS
00FD7F  1  A1           ESCVECT:   .BYTE   $A1          ; CLEOL-1
00FD80  1  84                      .BYTE   $84          ; CLEOP-1
00FD81  1  7C                      .BYTE   $7C          ; CLSCRN-1
00FD82  1  62                      .BYTE   $62          ; COL40-1
00FD83  1  5C                      .BYTE   $5C          ; COL80-1
00FD84  1  EC                      .BYTE   $EC          ; CURLEFT-1
00FD85  1  CA                      .BYTE   $CA          ; CURIGHT-1
00FD86  1  DC                      .BYTE   $DC          ; CURDOWN-1
00FD87  1  B7                      .BYTE   $B7          ; CURUP-1
00FD88  1               ;
00FD88  1  A5 5C        PICK:      LDA     CH           ; GET A CHARACTER AT CURRENT CURSOR POSITION
00FD8A  1  4A                      LSR     A            ; DETERMINE WHICH PAGE.
00FD8B  1  A8                      TAY
00FD8C  1  24 68                   BIT     MODES        ; AND IF 80 COLUMN MODE
00FD8E  1  50 05                   BVC     PICK40       ; FORGET CARRY IF 40 COLUMNS
00FD90  1  90 03                   BCC     PICK40       ; GET CHARACTER FROM $400
00FD92  1  B1 60                   LDA     (BAS8L),Y
00FD94  1  60                      RTS
00FD95  1  B1 5E        PICK40:    LDA     (BAS4L),Y
00FD97  1  60                      RTS
00FD98  1               ;
00FD98  1               CLDSTRT    =    *
00FD98  1  A9 03                   LDA     #03
00FD9A  1  8D D0 FF                STA     $FFD0        ; ZERO PAGE IS ON 3!
00FD9D  1               SETUP      =    *
00FD9D  1  D8                      CLD                  ; OF COURSE!
00FD9E  1  A2 03                   LDX     #03
00FDA0  1  86 7F                   STX     INBUF+1
00FDA2  1  BD BC FF     SETUP1:    LDA     NMIRQ,X
00FDA5  1  9D CA FF                STA     $FFCA,X
00FDA8  1  BD B4 FF                LDA     HOOKS,X
00FDAB  1  95 6E                   STA     CSWL,X
00FDAD  1  BD B8 FF                LDA     VBOUNDS,X
00FDB0  1  95 58                   STA     LMARGIN,X
00FDB2  1  CA                      DEX
00FDB3  1  10 ED                   BPL     SETUP1
00FDB5  1  85 82                   STA     IBDRVN
00FDB7  1  A9 A0                   LDA     #$A0         ; INPUT BUFFER AT $3A0
00FDB9  1  85 7E                   STA     INBUF
00FDBB  1  A9 60                   LDA     #$60
00FDBD  1  85 81                   STA     IBSLOT
00FDBF  1  A9 FF                   LDA     #$FF
00FDC1  1  85 68                   STA     MODES
00FDC3  1  20 63 FB                JSR     COL40        ; SET 40 COLUMNS, CLEAR SCREEN
00FDC6  1               
00FDC6  1               ADR        =    $A0
00FDC6  1               CPORTL     =    ADR
00FDC6  1               CPORTH     =    ADR+1
00FDC6  1               CTEMP      =    ADR+2
00FDC6  1               CTEMP1     =    ADR+3
00FDC6  1               YTEMP      =    ADR+4
00FDC6  1               ROWTEMP    =    ADR+$14
00FDC6  1               CWRTON     =    $C0DB
00FDC6  1               CWRTOFF    =    $C0DA
00FDC6  1               CB2CTRL    =    $FFEC
00FDC6  1               CB2INT     =    $FFED
00FDC6  1               ;
00FDC6  1               ;
00FDC6  1  A9 78        GENENTR:   LDA     #$78         ; INIT SCREEN INDX LOCATIONS
00FDC8  1  85 A0                   STA     CPORTL
00FDCA  1  A9 08                   LDA     #$08
00FDCC  1  85 A1                   STA     CPORTH
00FDCE  1  A9 F0                   LDA     #$F0         ; SET UP INDEX TO CHRSET
00FDD0  1  85 A4                   STA     YTEMP
00FDD2  1  A9 00                   LDA     #00
00FDD4  1  AA                      TAX
00FDD5  1  95 B4        ZIPTEMPS:  STA     ROWTEMP,X
00FDD7  1  E8                      INX
00FDD8  1  E0 20                   CPX     #$20
00FDDA  1  D0 F9                   BNE     ZIPTEMPS
00FDDC  1  A9 05                   LDA     #05          ; FAKE THE FIRST BIT PATTERN
00FDDE  1  18                      CLC                  ; (PHANTOM 9TH BIT SHIFTED AS BIT 0)
00FDDF  1  08                      PHP
00FDE0  1  48                      PHA
00FDE1  1  86 A2        GENASC:    STX     CTEMP        ; GENERATE THE ASCII
00FDE3  1  A0 07        GASCI1:    LDY     #07          ; CODES FOR THE FIRST PASS
00FDE5  1  A6 A2        GASCL2:    LDX     CTEMP
00FDE7  1  8A           GASCI3:    TXA
00FDE8  1  91 A0                   STA     (CPORTL),Y   ; $XXF=CHR 0 / 4
00FDEA  1  E8                      INX                  ; $XXE=CHR 1 / 5
00FDEB  1  88                      DEY                  ; $XXD=CHR 2 / 6
00FDEC  1  30 06                   BMI     GASCI4       ; $XXC=CHR 3 / 7
00FDEE  1  C0 03                   CPY     #03          ; $XXB=CHR 0 / 4
00FDF0  1  D0 F5                   BNE     GASCI3       ; $XXA=CHR 1 / 5
00FDF2  1  F0 F1                   BEQ     GASCL2       ; $XX9=CHR 2 / 6
00FDF4  1  20 99 FE     GASCI4:    JSR     NXTPORT      ; $XX8=CHR 3 / 7
00FDF7  1  B0 08                   BCS     CBYTES       ; GO DECODE CHARACTER TABLE
00FDF9  1  C9 0A                   CMP     #$0A         ; SECOND SET OF 4?
00FDFB  1  D0 E6                   BNE     GASCI1
00FDFD  1  A2 24                   LDX     #$24
00FDFF  1  D0 E0                   BNE     GENASC       ; BRANCH ALWAYS
00FE01  1  68           CBYTES:    PLA                  ; RESTORE BIT PATTERN
00FE02  1  28                      PLP
00FE03  1  A2 17                   LDX     #$17         ; (4 CHARACTERS OF 6 ROWS)
00FE05  1  A0 05        CCOLMS:    LDY     #05          ; (FIVE COLUMNS)
00FE07  1  36 B8        CSHFT:     ROL     ROWTEMP+4,X  ; BREAK BYTE INTO
00FE09  1  0A                      ASL     A            ; 5 BIT GROUPS
00FE0A  1  D0 0E                   BNE     SHFTCNT      ; BRANCH IF MORE BITS IN THIS BYTE
00FE0C  1  84 A2                   STY     CTEMP
00FE0E  1  C6 A4                   DEC     YTEMP        ; (NOTE. CARRY IS SET)
00FE10  1  F0 16                   BEQ     DONE         ; BRANCH IF ALL DONE
00FE12  1  A4 A4                   LDY     YTEMP        ; GET CHARACTER TABLE INDEX
00FE14  1  B9 C4 FE                LDA     CHRSET-1,Y
00FE17  1  2A                      ROL     A            ; (CARRY KEEPS BYTE NON-ZERO UNTIL ALL 8 ARE
00FE18  1                                               ; ARE SHIFTED)
00FE18  1  A4 A2                   LDY     CTEMP        ; RESTORE COLUMN COUNT
00FE1A  1  88           SHFTCNT:   DEY                  ; GOT ALL FIVE BITS?
00FE1B  1  D0 EA                   BNE     CSHFT        ; NO, DO NEXT
00FE1D  1  CA                      DEX                  ; ALL ROWS DONE
00FE1E  1  10 E5                   BPL     CCOLMS       ; NO, DO NEXT
00FE20  1  08                      PHP                  ; SAVE REMAINING BIT PATTERN AND CARRY
00FE21  1  48                      PHA
00FE22  1  20 28 FE                JSR     STORCHRS     ; MOVE EM TO NON DISPLAYED VIDEO AREA
00FE25  1  4C 01 FE                JMP     CBYTES
00FE28  1               ;
00FE28  1               DONE       =    *
00FE28  1               ;
00FE28  1  A2 1F        STORCHRS:  LDX     #$1F         ; MOVE CHARACTER PATTERNS TO VIDEO AREA
00FE2A  1  A0 00        STORSET:   LDY     #00
00FE2C  1  B5 B4        STOROW:    LDA     ROWTEMP,X
00FE2E  1  0A                      ASL     A            ; SHIFT TO CENTER
00FE2F  1  29 3E                   AND     #$3E         ; STRIP EXTRA GARBAGE
00FE31  1  91 A0                   STA     (CPORTL),Y
00FE33  1  CA                      DEX
00FE34  1  C8                      INY
00FE35  1  C0 08                   CPY     #$08         ; THIS GROUP DONE
00FE37  1  D0 F3                   BNE     STOROW       ; NO, NEXT ROW
00FE39  1  20 99 FE                JSR     NXTPORT
00FE3C  1  C9 08                   CMP     #$08
00FE3E  1  F0 04                   BEQ     GENDONE      ; ALL ROWS STORED?
00FE40  1  8A                      TXA
00FE41  1  10 E7                   BPL     STORSET
00FE43  1  60                      RTS                  ; PARTIAL SET ($478-$5FF)
00FE44  1               ;
00FE44  1  A9 01        GENDONE:   LDA     #$01         ; SET NORMAL MODE
00FE46  1  85 A2                   STA     CTEMP
00FE48  1  A9 60        GEN1:      LDA     #$60         ; PREPARE TO SEND BYTES TO CHARACTER
00FE4A  1  2C DB C0                BIT     CWRTON       ; GENERATOR RAM
00FE4D  1  20 AE FE                JSR     VRETRCE      ; WAIT FOR NEXT VERTICAL RETRACE
00FE50  1  A9 20                   LDA     #$20         ; WAIT AGAIN
00FE52  1  20 AE FE                JSR     VRETRCE
00FE55  1  2C DA C0                BIT     CWRTOFF      ; CHARACTERS ARE NOW LOADED
00FE58  1  20 88 FE                JSR     ALTCHR       ; REPEAT THIS SET FOR OTHER 64 CHARACTERS
00FE5B  1  C6 A2                   DEC     CTEMP        ; HAVE WE DONE ALTERNATES YET?
00FE5D  1  10 16                   BPL     GEN2         ; NO, DO IT!
00FE5F  1  A9 08                   LDA     #08          ; BUMP ASCII VALUES FOR NEXT SET
00FE61  1  85 A1                   STA     CPORTH
00FE63  1  A0 07        NXTASCI:   LDY     #07          ; THE USUAL COUNTDOWN
00FE65  1  B1 A0        NXTASC2:   LDA     (CPORTL),Y
00FE67  1  18                      CLC
00FE68  1  69 08                   ADC     #08
00FE6A  1  91 A0                   STA     (CPORTL),Y
00FE6C  1  88                      DEY
00FE6D  1  10 F6                   BPL     NXTASC2
00FE6F  1  20 99 FE                JSR     NXTPORT
00FE72  1  90 EF                   BCC     NXTASCI
00FE74  1  60                      RTS
00FE75  1  A0 03        GEN2:      LDY     #03          ; SETUP ALTERNATE WITH UNDERLINES
00FE77  1  A9 7F                   LDA     #$7F
00FE79  1  99 FC 05     UNDER:     STA     $05FC,Y
00FE7C  1  99 FC 07                STA     $07FC,Y
00FE7F  1  88                      DEY
00FE80  1  10 F7                   BPL     UNDER
00FE82  1  A9 08                   LDA     #08
00FE84  1  85 A1                   STA     CPORTH
00FE86  1  D0 C0                   BNE     GEN1
00FE88  1               ;
00FE88  1  A0 07        ALTCHR:    LDY     #07          ; ADJUST ASCII FOR ALTERNATE SET
00FE8A  1  B1 A0        ALTC1:     LDA     (CPORTL),Y
00FE8C  1  49 20                   EOR     #$20         ; $20-->  $40-->$60
00FE8E  1  91 A0                   STA     (CPORTL),Y
00FE90  1  88                      DEY
00FE91  1  10 F7                   BPL     ALTC1        ; ADJUST THEM ALL
00FE93  1  20 99 FE                JSR     NXTPORT
00FE96  1  90 F0                   BCC     ALTCHR
00FE98  1  60                      RTS
00FE99  1               ;
00FE99  1  A5 A0        NXTPORT:   LDA     CPORTL       ; CONVERT $78->$F8 OR $F8-$78
00FE9B  1  49 80                   EOR     #$80
00FE9D  1  85 A0                   STA     CPORTL
00FE9F  1  30 02                   BMI     NOHIGH
00FEA1  1  E6 A1                   INC     CPORTH
00FEA3  1  A5 A1        NOHIGH:    LDA     CPORTH
00FEA5  1  C9 0C                   CMP     #$0C
00FEA7  1  D0 04                   BNE     PORTDN
00FEA9  1  A9 04                   LDA     #04
00FEAB  1  85 A1                   STA     CPORTH
00FEAD  1  60           PORTDN:    RTS
00FEAE  1               ;
00FEAE  1  85 A3        VRETRCE:   STA     CTEMP1       ; SAVE BITS TO BE STORED
00FEB0  1  AD EC FF                LDA     CB2CTRL      ; CONTROL PORT FOR 'CB2'
00FEB3  1  29 3F                   AND     #$3F         ; RESET HI BITS TO 0
00FEB5  1  05 A3                   ORA     CTEMP1
00FEB7  1  8D EC FF                STA     CB2CTRL
00FEBA  1  A9 08                   LDA     #08          ; TEST VERTICAL RETRACE
00FEBC  1  8D ED FF                STA     CB2INT
00FEBF  1  2C ED FF     VWAIT:     BIT     CB2INT       ; WAIT FOR RETRACE
00FEC2  1  F0 FB                   BEQ     VWAIT
00FEC4  1  60                      RTS
00FEC5  1               ;
00FEC5  1               CHRSET     =    *
00FEC5  1               ;
00FEC5  1  F0 01 82 18             .BYTE   $F0,$01,$82,$18,$40,$84,$81,$2F,$58,$44,$81,$29,$02,$1E,$01,$91,$7C,$1F,$49,$30
00FEC9  1  40 84 81 2F  
00FECD  1  58 44 81 29  
00FED9  1  8A 08 43 14             .BYTE   $8A,$08,$43,$14,$31,$2A,$22,$13,$E3,$F7,$C4,$91,$48,$A2,$DA,$24,$C6,$4A
00FEDD  1  31 2A 22 13  
00FEE1  1  E3 F7 C4 91  
00FEEB  1  62 8C 24 C6             .BYTE   $62,$8C,$24,$C6,$F8,$63,$8C,$C1,$46,$17,$52,$8A,$AF,$16,$14,$E3,$33,$31
00FEEF  1  F8 63 8C C1  
00FEF3  1  46 17 52 8A  
00FEFD  1  C6 F8 DC 73             .BYTE   $C6,$F8,$DC,$73,$3F,$46,$17,$62,$8C,$21,$E6,$18,$6A,$8D,$61,$CF,$18,$62
00FF01  1  3F 46 17 62  
00FF05  1  8C 21 E6 18  
00FF0F  1  74 D1 B9 18             .BYTE   $74,$D1,$B9,$18,$49,$4C,$91,$C0,$F3,$09,$2C,$91,$C0,$14,$1D,$8C,$EF,$07
00FF13  1  49 4C 91 C0  
00FF17  1  F3 09 2C 91  
00FF21  1  17 43 88 31             .BYTE   $17,$43,$88,$31,$84,$1E,$DF,$0B,$31,$84,$F8,$FE,$77,$3E,$3E,$17,$62,$8C,$FD
00FF25  1  84 1E DF 0B  
00FF29  1  31 84 F8 FE  
00FF34  1  C7 50 E3 0B             .BYTE   $C7,$50,$E3,$0B,$51,$C5,$E8,$C8,$73,$18,$0C,$42,$3E,$01,$02,$20,$42,$3E
00FF38  1  51 C5 E8 C8  
00FF3C  1  73 18 0C 42  
00FF46  1  41 18 8C 08             .BYTE   $41,$18,$8C,$08,$00,$70,$EE,$00,$11,$11,$21,$11,$02,$E0,$3C,$21,$31,$02,$E0
00FF4A  1  00 70 EE 00  
00FF4E  1  11 11 21 11  
00FF59  1  1C 00 C8 B9             .BYTE   $1C,$00,$C8,$B9,$80,$62,$14,$1F,$46,$A2,$DE,$43,$2C,$04,$88,$BE,$FF,$CE
00FF5D  1  80 62 14 1F  
00FF61  1  46 A2 DE 43  
00FF6B  1  7D 37 49 88             .BYTE   $7D,$37,$49,$88,$95,$18,$98,$09,$62,$D1,$44,$E8,$88,$FB,$02,$90,$40,$00,$10
00FF6F  1  95 18 98 09  
00FF73  1  62 D1 44 E8  
00FF7E  1  E0 03 02 00             .BYTE   $E0,$03,$02,$00,$40,$00,$00,$08,$00,$00,$28,$10,$42,$44,$25,$82,$B8,$2F,$48
00FF82  1  40 00 00 08  
00FF86  1  00 00 28 10  
00FF91  1  25 44 10 82             .BYTE   $25,$44,$10,$82,$02,$00,$2F,$5A,$40,$45,$02,$8E,$64,$50,$90,$01,$3E,$26,$42,$80
00FF95  1  02 00 2F 5A  
00FF99  1  40 45 02 8E  
00FFA5  1  21 80 00 05             .BYTE   $21,$80,$00,$05,$00,$F8,$80,$00,$05,$08,$F8,$80,$28,$05,$88
00FFA9  1  00 F8 80 00  
00FFAD  1  05 08 F8 80  
00FFB4  1               ;
00FFB4  1               HOOKS      =    *
00FFB4  1  06 FC                   .WORD   COUT2
00FFB6  1  0F FD                   .WORD   KEYIN
00FFB8  1               VBOUNDS    =    *
00FFB8  1  00 50 00 18             .BYTE   $00,$50,$00,$18
00FFBC  1               ;
00FFBC  1  4C 86 F6     NMIRQ:     JMP     RECON        ; IN DIAGNOSTICS
00FFBF  1  40                      RTI
00FFC0  1               ;
00FFC0  1               ;          ROM HAS HIGH BIT SET FOR ASCII CHARACTERS
00FFC0  1               ;          341-0031-01
00FFC0  1               ;          "(C) COPYRIGHT JULY, 1980 APPLE COMPUTER INC. JRH"
00FFC0  1               ;
00FFC0  1  A8 C3 A9 A0             .BYTE   $A8,$C3,$A9,$A0,$C3,$CF,$D0,$D9,$D2,$C9,$C7,$C8,$D4,$A0,$CA,$D5
00FFC4  1  C3 CF D0 D9  
00FFC8  1  D2 C9 C7 C8  
00FFD0  1  CC D9 AC A0             .BYTE   $CC,$D9,$AC,$A0,$B1,$B9,$B8,$B0,$A0,$C1,$D0,$D0,$CC,$C5,$A0,$C3
00FFD4  1  B1 B9 B8 B0  
00FFD8  1  A0 C1 D0 D0  
00FFE0  1  CF CD D0 D5             .BYTE   $CF,$CD,$D0,$D5,$D4,$C5,$D2,$A0,$C9,$CE,$C3,$AE,$A0,$CA,$D2,$C8
00FFE4  1  D4 C5 D2 A0  
00FFE8  1  C9 CE C3 AE  
00FFF0  1               ;
00FFF0  1  CC D0 D3 B4  ESCTABL:   .BYTE   $CC,$D0,$D3,$B4,$B8,$88,$95,$8A,$8B,$00
00FFF4  1  B8 88 95 8A  
00FFF8  1  8B 00        
00FFFA  1               ;
00FFFA  1               
00FFFA  1  CA FF        NMI:       .WORD   $FFCA
00FFFC  1  EE F4        RESET:     .WORD   DIAGN        ; NOTHING
00FFFE  1  CD FF        IRQ:       .WORD   $FFCD
010000  1               
010000  1               ;          .END
010000  1               
